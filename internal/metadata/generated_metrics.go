// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"go.opentelemetry.io/collector/filter"
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

type metricServicebusQueueActiveMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.queue.active_messages metric with initial data.
func (m *metricServicebusQueueActiveMessages) init() {
	m.data.SetName("servicebus.queue.active_messages")
	m.data.SetDescription("The number of active messages on the Service Bus queue")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusQueueActiveMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("queue", queueAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusQueueActiveMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusQueueActiveMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusQueueActiveMessages(cfg MetricConfig) metricServicebusQueueActiveMessages {
	m := metricServicebusQueueActiveMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusQueueCurrentSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.queue.current_size metric with initial data.
func (m *metricServicebusQueueCurrentSize) init() {
	m.data.SetName("servicebus.queue.current_size")
	m.data.SetDescription("The current size of the Service Bus queue in bytes")
	m.data.SetUnit("{bytes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusQueueCurrentSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("queue", queueAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusQueueCurrentSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusQueueCurrentSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusQueueCurrentSize(cfg MetricConfig) metricServicebusQueueCurrentSize {
	m := metricServicebusQueueCurrentSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusQueueDeadletterMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.queue.deadletter_messages metric with initial data.
func (m *metricServicebusQueueDeadletterMessages) init() {
	m.data.SetName("servicebus.queue.deadletter_messages")
	m.data.SetDescription("The number of deadletter messages on the Service Bus queue")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusQueueDeadletterMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("queue", queueAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusQueueDeadletterMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusQueueDeadletterMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusQueueDeadletterMessages(cfg MetricConfig) metricServicebusQueueDeadletterMessages {
	m := metricServicebusQueueDeadletterMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusQueueMaxSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.queue.max_size metric with initial data.
func (m *metricServicebusQueueMaxSize) init() {
	m.data.SetName("servicebus.queue.max_size")
	m.data.SetDescription("The max size of the Service Bus queue in bytes")
	m.data.SetUnit("{bytes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusQueueMaxSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("queue", queueAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusQueueMaxSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusQueueMaxSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusQueueMaxSize(cfg MetricConfig) metricServicebusQueueMaxSize {
	m := metricServicebusQueueMaxSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusQueueScheduledMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.queue.scheduled_messages metric with initial data.
func (m *metricServicebusQueueScheduledMessages) init() {
	m.data.SetName("servicebus.queue.scheduled_messages")
	m.data.SetDescription("The number of scheduled messages on the Service Bus queue")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusQueueScheduledMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("queue", queueAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusQueueScheduledMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusQueueScheduledMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusQueueScheduledMessages(cfg MetricConfig) metricServicebusQueueScheduledMessages {
	m := metricServicebusQueueScheduledMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusTopicCurrentSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.topic.current_size metric with initial data.
func (m *metricServicebusTopicCurrentSize) init() {
	m.data.SetName("servicebus.topic.current_size")
	m.data.SetDescription("The current size of the Service Bus topic in bytes")
	m.data.SetUnit("{bytes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusTopicCurrentSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("topic", topicAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusTopicCurrentSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusTopicCurrentSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusTopicCurrentSize(cfg MetricConfig) metricServicebusTopicCurrentSize {
	m := metricServicebusTopicCurrentSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusTopicMaxSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.topic.max_size metric with initial data.
func (m *metricServicebusTopicMaxSize) init() {
	m.data.SetName("servicebus.topic.max_size")
	m.data.SetDescription("The max size of the Service Bus topic in bytes")
	m.data.SetUnit("{bytes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusTopicMaxSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("topic", topicAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusTopicMaxSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusTopicMaxSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusTopicMaxSize(cfg MetricConfig) metricServicebusTopicMaxSize {
	m := metricServicebusTopicMaxSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusTopicScheduledMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.topic.scheduled_messages metric with initial data.
func (m *metricServicebusTopicScheduledMessages) init() {
	m.data.SetName("servicebus.topic.scheduled_messages")
	m.data.SetDescription("The number of scheduled messages on the Service Bus topic")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusTopicScheduledMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("topic", topicAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusTopicScheduledMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusTopicScheduledMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusTopicScheduledMessages(cfg MetricConfig) metricServicebusTopicScheduledMessages {
	m := metricServicebusTopicScheduledMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusTopicSubscriptionActiveMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.topic.subscription.active_messages metric with initial data.
func (m *metricServicebusTopicSubscriptionActiveMessages) init() {
	m.data.SetName("servicebus.topic.subscription.active_messages")
	m.data.SetDescription("The number of active messages on the Service Bus topic subscription")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusTopicSubscriptionActiveMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, topicAttributeValue string, subscriptionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("topic", topicAttributeValue)
	dp.Attributes().PutStr("subscription", subscriptionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusTopicSubscriptionActiveMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusTopicSubscriptionActiveMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusTopicSubscriptionActiveMessages(cfg MetricConfig) metricServicebusTopicSubscriptionActiveMessages {
	m := metricServicebusTopicSubscriptionActiveMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricServicebusTopicSubscriptionDeadletterMessages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills servicebus.topic.subscription.deadletter_messages metric with initial data.
func (m *metricServicebusTopicSubscriptionDeadletterMessages) init() {
	m.data.SetName("servicebus.topic.subscription.deadletter_messages")
	m.data.SetDescription("The number of deadletter messages on the Service Bus topic subscription")
	m.data.SetUnit("{messages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricServicebusTopicSubscriptionDeadletterMessages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, topicAttributeValue string, subscriptionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("topic", topicAttributeValue)
	dp.Attributes().PutStr("subscription", subscriptionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricServicebusTopicSubscriptionDeadletterMessages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricServicebusTopicSubscriptionDeadletterMessages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricServicebusTopicSubscriptionDeadletterMessages(cfg MetricConfig) metricServicebusTopicSubscriptionDeadletterMessages {
	m := metricServicebusTopicSubscriptionDeadletterMessages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                              MetricsBuilderConfig // config of the metrics builder.
	startTime                                           pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                     int                  // maximum observed number of metrics per resource.
	metricsBuffer                                       pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                           component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                      map[string]filter.Filter
	resourceAttributeExcludeFilter                      map[string]filter.Filter
	metricServicebusQueueActiveMessages                 metricServicebusQueueActiveMessages
	metricServicebusQueueCurrentSize                    metricServicebusQueueCurrentSize
	metricServicebusQueueDeadletterMessages             metricServicebusQueueDeadletterMessages
	metricServicebusQueueMaxSize                        metricServicebusQueueMaxSize
	metricServicebusQueueScheduledMessages              metricServicebusQueueScheduledMessages
	metricServicebusTopicCurrentSize                    metricServicebusTopicCurrentSize
	metricServicebusTopicMaxSize                        metricServicebusTopicMaxSize
	metricServicebusTopicScheduledMessages              metricServicebusTopicScheduledMessages
	metricServicebusTopicSubscriptionActiveMessages     metricServicebusTopicSubscriptionActiveMessages
	metricServicebusTopicSubscriptionDeadletterMessages metricServicebusTopicSubscriptionDeadletterMessages
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                              mbc,
		startTime:                                           pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                       pmetric.NewMetrics(),
		buildInfo:                                           settings.BuildInfo,
		metricServicebusQueueActiveMessages:                 newMetricServicebusQueueActiveMessages(mbc.Metrics.ServicebusQueueActiveMessages),
		metricServicebusQueueCurrentSize:                    newMetricServicebusQueueCurrentSize(mbc.Metrics.ServicebusQueueCurrentSize),
		metricServicebusQueueDeadletterMessages:             newMetricServicebusQueueDeadletterMessages(mbc.Metrics.ServicebusQueueDeadletterMessages),
		metricServicebusQueueMaxSize:                        newMetricServicebusQueueMaxSize(mbc.Metrics.ServicebusQueueMaxSize),
		metricServicebusQueueScheduledMessages:              newMetricServicebusQueueScheduledMessages(mbc.Metrics.ServicebusQueueScheduledMessages),
		metricServicebusTopicCurrentSize:                    newMetricServicebusTopicCurrentSize(mbc.Metrics.ServicebusTopicCurrentSize),
		metricServicebusTopicMaxSize:                        newMetricServicebusTopicMaxSize(mbc.Metrics.ServicebusTopicMaxSize),
		metricServicebusTopicScheduledMessages:              newMetricServicebusTopicScheduledMessages(mbc.Metrics.ServicebusTopicScheduledMessages),
		metricServicebusTopicSubscriptionActiveMessages:     newMetricServicebusTopicSubscriptionActiveMessages(mbc.Metrics.ServicebusTopicSubscriptionActiveMessages),
		metricServicebusTopicSubscriptionDeadletterMessages: newMetricServicebusTopicSubscriptionDeadletterMessages(mbc.Metrics.ServicebusTopicSubscriptionDeadletterMessages),
		resourceAttributeIncludeFilter:                      make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                      make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.ServicebusNamespaceName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["servicebus.namespace.name"] = filter.CreateFilter(mbc.ResourceAttributes.ServicebusNamespaceName.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServicebusNamespaceName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["servicebus.namespace.name"] = filter.CreateFilter(mbc.ResourceAttributes.ServicebusNamespaceName.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("go.opentelemetry.io/collector/cmd/mdatagen")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricServicebusQueueActiveMessages.emit(ils.Metrics())
	mb.metricServicebusQueueCurrentSize.emit(ils.Metrics())
	mb.metricServicebusQueueDeadletterMessages.emit(ils.Metrics())
	mb.metricServicebusQueueMaxSize.emit(ils.Metrics())
	mb.metricServicebusQueueScheduledMessages.emit(ils.Metrics())
	mb.metricServicebusTopicCurrentSize.emit(ils.Metrics())
	mb.metricServicebusTopicMaxSize.emit(ils.Metrics())
	mb.metricServicebusTopicScheduledMessages.emit(ils.Metrics())
	mb.metricServicebusTopicSubscriptionActiveMessages.emit(ils.Metrics())
	mb.metricServicebusTopicSubscriptionDeadletterMessages.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordServicebusQueueActiveMessagesDataPoint adds a data point to servicebus.queue.active_messages metric.
func (mb *MetricsBuilder) RecordServicebusQueueActiveMessagesDataPoint(ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	mb.metricServicebusQueueActiveMessages.recordDataPoint(mb.startTime, ts, val, queueAttributeValue)
}

// RecordServicebusQueueCurrentSizeDataPoint adds a data point to servicebus.queue.current_size metric.
func (mb *MetricsBuilder) RecordServicebusQueueCurrentSizeDataPoint(ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	mb.metricServicebusQueueCurrentSize.recordDataPoint(mb.startTime, ts, val, queueAttributeValue)
}

// RecordServicebusQueueDeadletterMessagesDataPoint adds a data point to servicebus.queue.deadletter_messages metric.
func (mb *MetricsBuilder) RecordServicebusQueueDeadletterMessagesDataPoint(ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	mb.metricServicebusQueueDeadletterMessages.recordDataPoint(mb.startTime, ts, val, queueAttributeValue)
}

// RecordServicebusQueueMaxSizeDataPoint adds a data point to servicebus.queue.max_size metric.
func (mb *MetricsBuilder) RecordServicebusQueueMaxSizeDataPoint(ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	mb.metricServicebusQueueMaxSize.recordDataPoint(mb.startTime, ts, val, queueAttributeValue)
}

// RecordServicebusQueueScheduledMessagesDataPoint adds a data point to servicebus.queue.scheduled_messages metric.
func (mb *MetricsBuilder) RecordServicebusQueueScheduledMessagesDataPoint(ts pcommon.Timestamp, val int64, queueAttributeValue string) {
	mb.metricServicebusQueueScheduledMessages.recordDataPoint(mb.startTime, ts, val, queueAttributeValue)
}

// RecordServicebusTopicCurrentSizeDataPoint adds a data point to servicebus.topic.current_size metric.
func (mb *MetricsBuilder) RecordServicebusTopicCurrentSizeDataPoint(ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	mb.metricServicebusTopicCurrentSize.recordDataPoint(mb.startTime, ts, val, topicAttributeValue)
}

// RecordServicebusTopicMaxSizeDataPoint adds a data point to servicebus.topic.max_size metric.
func (mb *MetricsBuilder) RecordServicebusTopicMaxSizeDataPoint(ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	mb.metricServicebusTopicMaxSize.recordDataPoint(mb.startTime, ts, val, topicAttributeValue)
}

// RecordServicebusTopicScheduledMessagesDataPoint adds a data point to servicebus.topic.scheduled_messages metric.
func (mb *MetricsBuilder) RecordServicebusTopicScheduledMessagesDataPoint(ts pcommon.Timestamp, val int64, topicAttributeValue string) {
	mb.metricServicebusTopicScheduledMessages.recordDataPoint(mb.startTime, ts, val, topicAttributeValue)
}

// RecordServicebusTopicSubscriptionActiveMessagesDataPoint adds a data point to servicebus.topic.subscription.active_messages metric.
func (mb *MetricsBuilder) RecordServicebusTopicSubscriptionActiveMessagesDataPoint(ts pcommon.Timestamp, val int64, topicAttributeValue string, subscriptionAttributeValue string) {
	mb.metricServicebusTopicSubscriptionActiveMessages.recordDataPoint(mb.startTime, ts, val, topicAttributeValue, subscriptionAttributeValue)
}

// RecordServicebusTopicSubscriptionDeadletterMessagesDataPoint adds a data point to servicebus.topic.subscription.deadletter_messages metric.
func (mb *MetricsBuilder) RecordServicebusTopicSubscriptionDeadletterMessagesDataPoint(ts pcommon.Timestamp, val int64, topicAttributeValue string, subscriptionAttributeValue string) {
	mb.metricServicebusTopicSubscriptionDeadletterMessages.recordDataPoint(mb.startTime, ts, val, topicAttributeValue, subscriptionAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
